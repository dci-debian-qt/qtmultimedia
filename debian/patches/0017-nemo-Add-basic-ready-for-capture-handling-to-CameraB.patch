From 97905ab0d0bdfa6be61ee2ca6337d65e8f66afdb Mon Sep 17 00:00:00 2001
From: Mohammed Hassan <mohammed.hassan@jolla.com>
Date: Thu, 30 Jun 2016 02:42:02 +0300
Subject: [PATCH 2/3] nemo: Add basic ready-for-capture handling to
 CameraBinSession

This property is provided and controlled by the camera source and should be used to tell
whether the camera source can capture more or not

Conflicts:
	src/plugins/gstreamer/camerabin/camerabinsession.h
---
 .../gstreamer/camerabin/camerabinsession.cpp       | 23 ++++++++++++++++++++++
 src/plugins/gstreamer/camerabin/camerabinsession.h |  4 ++++
 2 files changed, 27 insertions(+)

diff --git a/src/plugins/gstreamer/camerabin/camerabinsession.cpp b/src/plugins/gstreamer/camerabin/camerabinsession.cpp
index d70663d9..92579c90 100644
--- a/src/plugins/gstreamer/camerabin/camerabinsession.cpp
+++ b/src/plugins/gstreamer/camerabin/camerabinsession.cpp
@@ -124,6 +124,7 @@ CameraBinSession::CameraBinSession(GstElementFactory *sourceFactory, QObject *pa
      m_pendingState(QCamera::UnloadedState),
      m_muted(false),
      m_busy(false),
+     m_readyForCapture(false),
      m_captureMode(QCamera::CaptureStillImage),
      m_audioInputFactory(0),
      m_videoInputFactory(0),
@@ -549,6 +550,8 @@ GstElement *CameraBinSession::buildCameraSource()
         // Unref only if camSrc is not m_cameraSrc to prevent double unrefing.
         if (camSrc)
             gst_object_unref(GST_OBJECT(camSrc));
+
+        g_signal_connect(G_OBJECT(m_cameraSrc), "notify::ready-for-capture", G_CALLBACK(updateReadyForCapture), this);
     }
 
     return m_cameraSrc;
@@ -858,6 +861,11 @@ bool CameraBinSession::isBusy() const
     return m_busy;
 }
 
+bool CameraBinSession::isReadyForCapture() const
+{
+    return m_readyForCapture;
+}
+
 void CameraBinSession::updateBusyStatus(GObject *o, GParamSpec *p, gpointer d)
 {
     Q_UNUSED(p);
@@ -875,6 +883,21 @@ void CameraBinSession::updateBusyStatus(GObject *o, GParamSpec *p, gpointer d)
     }
 }
 
+void CameraBinSession::updateReadyForCapture(GObject *o, GParamSpec *p, gpointer d)
+{
+    Q_UNUSED(o);
+    Q_UNUSED(p);
+
+    CameraBinSession *session = reinterpret_cast<CameraBinSession *>(d);
+    gboolean ready = false;
+    g_object_get(o, "ready-for-capture", &ready, NULL);
+    if (session->m_readyForCapture != ready) {
+        session->m_readyForCapture = ready;
+        QMetaObject::invokeMethod(session, "handleReadyForCaptureChanged",
+                                  Qt::QueuedConnection, Q_ARG(bool, ready));
+    }
+}
+
 qint64 CameraBinSession::duration() const
 {
     if (m_camerabin) {
diff --git a/src/plugins/gstreamer/camerabin/camerabinsession.h b/src/plugins/gstreamer/camerabin/camerabinsession.h
index f88a2b41..203efe43 100644
--- a/src/plugins/gstreamer/camerabin/camerabinsession.h
+++ b/src/plugins/gstreamer/camerabin/camerabinsession.h
@@ -152,6 +152,7 @@ public:
     QCamera::Status status() const;
     QCamera::State pendingState() const;
     bool isBusy() const;
+    bool isReadyForCapture() const;
 
     qint64 duration() const;
 
@@ -178,6 +179,7 @@ signals:
     void viewfinderChanged();
     void readyChanged(bool);
     void busyChanged(bool);
+    void handleReadyForCaptureChanged(bool);
 
 public slots:
     void setDevice(const QString &device);
@@ -206,6 +208,7 @@ private:
     GstCaps *supportedCaps(QCamera::CaptureModes mode) const;
     void updateSupportedViewfinderSettings();
     static void updateBusyStatus(GObject *o, GParamSpec *p, gpointer d);
+    static void updateReadyForCapture(GObject *o, GParamSpec *p, gpointer d);
 
     QString currentContainerFormat() const;
 
@@ -221,6 +224,7 @@ private:
     QString m_inputDevice;
     bool m_muted;
     bool m_busy;
+    bool m_readyForCapture;
     QMediaStorageLocation m_mediaStorageLocation;
 
     QCamera::CaptureModes m_captureMode;
-- 
2.15.1

